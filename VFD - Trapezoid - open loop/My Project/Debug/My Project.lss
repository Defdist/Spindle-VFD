
My Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000382  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000032e  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000382  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000003b4  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000e8  00000000  00000000  000003f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001245  00000000  00000000  000004e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d5b  00000000  00000000  00001725  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000007a8  00000000  00000000  00002480  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000140  00000000  00000000  00002c28  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000006f7  00000000  00000000  00002d68  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000028d  00000000  00000000  0000345f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000088  00000000  00000000  000036ec  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
   8:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
   c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  10:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  14:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  18:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  1c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  20:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  24:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  28:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  2c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  30:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  34:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  38:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  3c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  40:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  44:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  48:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  4c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  50:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  54:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  58:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  5c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  60:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  64:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  68:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  6c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  70:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  74:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  78:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d8 e0       	ldi	r29, 0x08	; 8
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61
  88:	0e 94 22 01 	call	0x244	; 0x244 <main>
  8c:	0c 94 95 01 	jmp	0x32a	; 0x32a <_exit>

00000090 <__bad_interrupt>:
  90:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000094 <adc_select_vref>:


void adc_select_vref(uint8_t reference)
{
	//"The user is advised not to write new reference selection values during Free Running mode"
	ADCSRA &= ~(1<<ADSC); //disable free running mode
  94:	ea e7       	ldi	r30, 0x7A	; 122
  96:	f0 e0       	ldi	r31, 0x00	; 0
  98:	90 81       	ld	r25, Z
  9a:	9f 7b       	andi	r25, 0xBF	; 191
  9c:	90 83       	st	Z, r25
	//while ( !(ADCSRA & (1<<ADIF)) ) {;} //wait for ADC to stop
	if(reference == VREF_EXT_AVCC) {ADMUX = ( (ADMUX & 0b00111111) | (1<<REFS0) ); } //sets ADMUX to b01xxxxxx
  9e:	81 11       	cpse	r24, r1
  a0:	07 c0       	rjmp	.+14     	; 0xb0 <adc_select_vref+0x1c>
  a2:	ec e7       	ldi	r30, 0x7C	; 124
  a4:	f0 e0       	ldi	r31, 0x00	; 0
  a6:	80 81       	ld	r24, Z
  a8:	8f 73       	andi	r24, 0x3F	; 63
  aa:	80 64       	ori	r24, 0x40	; 64
  ac:	80 83       	st	Z, r24
  ae:	08 95       	ret
	if(reference == VREF_INT_2V56) {ADMUX |= ( (1<<REFS0) | (1<<REFS1) ); } //sets ADMUX to b11xxxxxx
  b0:	81 30       	cpi	r24, 0x01	; 1
  b2:	29 f4       	brne	.+10     	; 0xbe <adc_select_vref+0x2a>
  b4:	ec e7       	ldi	r30, 0x7C	; 124
  b6:	f0 e0       	ldi	r31, 0x00	; 0
  b8:	80 81       	ld	r24, Z
  ba:	80 6c       	ori	r24, 0xC0	; 192
  bc:	80 83       	st	Z, r24
  be:	08 95       	ret

000000c0 <adc_select_channel>:


void adc_select_channel(uint8_t channel)
{
	//"The user is advised not to write new channel selection values during Free Running mode"
	ADCSRA &= ~(1<<ADSC); //disable free running mode
  c0:	ea e7       	ldi	r30, 0x7A	; 122
  c2:	f0 e0       	ldi	r31, 0x00	; 0
  c4:	90 81       	ld	r25, Z
  c6:	9f 7b       	andi	r25, 0xBF	; 191
  c8:	90 83       	st	Z, r25
	//while ( !(ADCSRA & (1<<ADIF)) ) {;} //wait for ADC to stop
	if(     channel == ADC_CHANNEL_goalRPM) {ADMUX = ( (ADMUX & 0b11100000) | 0b00000101 ); } //ADC5 (single ended)
  ca:	81 11       	cpse	r24, r1
  cc:	07 c0       	rjmp	.+14     	; 0xdc <adc_select_channel+0x1c>
  ce:	ec e7       	ldi	r30, 0x7C	; 124
  d0:	f0 e0       	ldi	r31, 0x00	; 0
  d2:	80 81       	ld	r24, Z
  d4:	80 7e       	andi	r24, 0xE0	; 224
  d6:	85 60       	ori	r24, 0x05	; 5
  d8:	80 83       	st	Z, r24
  da:	08 95       	ret
	else if(channel == ADC_CHANNEL_VCCDIV4) {ADMUX = ( (ADMUX & 0b11100000) | 0b00001100 ); } //VCC/4 (SE)
  dc:	85 30       	cpi	r24, 0x05	; 5
  de:	31 f4       	brne	.+12     	; 0xec <adc_select_channel+0x2c>
  e0:	ec e7       	ldi	r30, 0x7C	; 124
  e2:	f0 e0       	ldi	r31, 0x00	; 0
  e4:	80 81       	ld	r24, Z
  e6:	80 7e       	andi	r24, 0xE0	; 224
  e8:	8c 60       	ori	r24, 0x0C	; 12
  ea:	80 83       	st	Z, r24
  ec:	08 95       	ret

000000ee <adc_init>:
	//ADCSRA |= (1<<ADSC); //enable free running mode
}


void adc_init()
{	
  ee:	0f 93       	push	r16
  f0:	1f 93       	push	r17
  f2:	cf 93       	push	r28
  f4:	df 93       	push	r29
	DIDR0 = (1<<ADC5D);//disable digital logic on adc pin (to reduce power)(see DIDR0/DIDR1)
  f6:	80 e2       	ldi	r24, 0x20	; 32
  f8:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
	PRR &= ~(1<<PRADC); //enable system clock to ADC.  This is default value, but just making sure ADC is on
  fc:	e4 e6       	ldi	r30, 0x64	; 100
  fe:	f0 e0       	ldi	r31, 0x00	; 0
 100:	80 81       	ld	r24, Z
 102:	8e 7f       	andi	r24, 0xFE	; 254
 104:	80 83       	st	Z, r24
	ADC_goalRPM_PORT &= ~(1<<ADC_goalRPM_BIT); //disable goalRPM pullup resistor
 106:	2a 98       	cbi	0x05, 2	; 5

	ADCSRA = 0; //reset to default values
 108:	ca e7       	ldi	r28, 0x7A	; 122
 10a:	d0 e0       	ldi	r29, 0x00	; 0
 10c:	18 82       	st	Y, r1
	ADCSRA |= (1<<ADEN); //enable ADC subsystem (but doesn't actually start)
 10e:	88 81       	ld	r24, Y
 110:	80 68       	ori	r24, 0x80	; 128
 112:	88 83       	st	Y, r24
	ADCSRA |= 0b00000110; //ADPS: sets ADC clock to 16E6/64 = 250 kHz (max anecdotal supported is clock = 2 MHz).  Conversion takes 16 clock cycles, so ~15 kS/s.
 114:	88 81       	ld	r24, Y
 116:	86 60       	ori	r24, 0x06	; 6
 118:	88 83       	st	Y, r24
	ADCSRA |= (1<<ADATE); //auto-trigger enable... ADC is just always digitizing.  When we want a value, we just grab the last one acquired
 11a:	88 81       	ld	r24, Y
 11c:	80 62       	ori	r24, 0x20	; 32
 11e:	88 83       	st	Y, r24
		
	ADCSRB = 0; //reset to default values
 120:	eb e7       	ldi	r30, 0x7B	; 123
 122:	f0 e0       	ldi	r31, 0x00	; 0
 124:	10 82       	st	Z, r1
	ADCSRB |= (1<<ADHSM); //uncomment to enable high speed mode.  max ADC rate with this line commented out is 200 kHz 
 126:	80 81       	ld	r24, Z
 128:	80 68       	ori	r24, 0x80	; 128
 12a:	80 83       	st	Z, r24
	ADCSRB |= (1<<AREFEN); //connect analog reference to external AREF pin (with capacitor)
 12c:	80 81       	ld	r24, Z
 12e:	80 62       	ori	r24, 0x20	; 32
 130:	80 83       	st	Z, r24
	//ADCSRB 3:0 sets auto-trigger source selection bits 0b0000 is "free running mode", which we're using for now

	
	ADMUX = 0; //reset 
 132:	0c e7       	ldi	r16, 0x7C	; 124
 134:	10 e0       	ldi	r17, 0x00	; 0
 136:	f8 01       	movw	r30, r16
 138:	10 82       	st	Z, r1
	adc_select_vref(VREF_EXT_AVCC);  //modifies ADMUX, so needs to happen after "ADMUX=0;"
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	0e 94 4a 00 	call	0x94	; 0x94 <adc_select_vref>
	adc_select_channel(ADC_CHANNEL_goalRPM); // "always select a channel before starting the first conversion"
 140:	80 e0       	ldi	r24, 0x00	; 0
 142:	0e 94 60 00 	call	0xc0	; 0xc0 <adc_select_channel>
	ADMUX |= (1<<ADLAR); //left adjust ADC result, so that upper 8 bits are in ADCH
 146:	f8 01       	movw	r30, r16
 148:	80 81       	ld	r24, Z
 14a:	80 62       	ori	r24, 0x20	; 32
 14c:	80 83       	st	Z, r24


	ADCSRA |= (1<<ADSC); //start ADC conversion (since we're free running, we only need to set bit once)
 14e:	88 81       	ld	r24, Y
 150:	80 64       	ori	r24, 0x40	; 64
 152:	88 83       	st	Y, r24
}
 154:	df 91       	pop	r29
 156:	cf 91       	pop	r28
 158:	1f 91       	pop	r17
 15a:	0f 91       	pop	r16
 15c:	08 95       	ret

0000015e <adc_read_latest>:

//returns the latest measurement (8 bits for now)
uint8_t adc_read_latest()
{
	uint8_t adc_result = 0;
	adc_result = ADCH; //high byte ADC result
 15e:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
	return adc_result; //only 8 MSBs returned (2 LSBs in ADCL not read).  Search ADLAR to enable 10b (and note this requires two register reads, etc)
 162:	08 95       	ret

00000164 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
 164:	0e 94 6f 01 	call	0x2de	; 0x2de <system_init>
 168:	08 95       	ret

0000016a <timer0_init>:
}

//setup TC0 to continuously count from 0:127 with auto-reload
void timer0_init()
{
	PRR &= ~(1<<PRTIM0);//enable timer
 16a:	e4 e6       	ldi	r30, 0x64	; 100
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	80 81       	ld	r24, Z
 170:	87 7f       	andi	r24, 0xF7	; 247
 172:	80 83       	st	Z, r24
	TCCR0A = 0b10000010; //set to clear on compare
 174:	82 e8       	ldi	r24, 0x82	; 130
 176:	84 bd       	out	0x24, r24	; 36
	//TCCR0B = 0b00000101; //divide 16E6/1024 = 15.6 kHz clock, counter resets @   117  Hz
	//TCCR0B = 0b00000100; //divide 16E6/0256 = 62.5 kHz clock, counter resets @   488  Hz
	//TCCR0B = 0b00000011; //divide 16E6/0064 = 250. kHz clock, counter resets @  1.95 kHz
	TCCR0B = 0b00000010; //divide 16E6/0008 = 02.0 MHz clock, counter resets @ 15.63 kHz
 178:	82 e0       	ldi	r24, 0x02	; 2
 17a:	85 bd       	out	0x25, r24	; 37
	//TCCR0B = 0b00000001; //divide 16E6/0001 = 16.0 MHz clock, counter resets @   125 kHz
	
	OCR0A = 127; //maximum timer value to count up to (before reset); counter continuously counts up from zero to this value 
 17c:	8f e7       	ldi	r24, 0x7F	; 127
 17e:	87 bd       	out	0x27, r24	; 39
 180:	08 95       	ret

00000182 <phase_init>:
}

void phase_init()
{
	//Pull enable pin high
	BLDC_ENABLE_DDR |= BLDC_ENABLE_MASK; //configure as output
 182:	24 9a       	sbi	0x04, 4	; 4
	BLDC_ENABLE_PORT |= BLDC_ENABLE_MASK; //set pin high
 184:	2c 9a       	sbi	0x05, 4	; 5
	
	//configure phases as output
	DDRB |= FET_PORTB_MASK;
 186:	84 b1       	in	r24, 0x04	; 4
 188:	83 6c       	ori	r24, 0xC3	; 195
 18a:	84 b9       	out	0x04, r24	; 4
	DDRC |= FET_PORTC_MASK;
 18c:	38 9a       	sbi	0x07, 0	; 7
	DDRD |= FET_PORTD_MASK;
 18e:	50 9a       	sbi	0x0a, 0	; 10
	
	//set pins low
	PORTB &= ~(FET_PORTB_MASK);
 190:	85 b1       	in	r24, 0x05	; 5
 192:	8c 73       	andi	r24, 0x3C	; 60
 194:	85 b9       	out	0x05, r24	; 5
	PORTC &= ~(FET_PORTB_MASK);
 196:	88 b1       	in	r24, 0x08	; 8
 198:	8c 73       	andi	r24, 0x3C	; 60
 19a:	88 b9       	out	0x08, r24	; 8
	PORTD &= ~(FET_PORTB_MASK);
 19c:	8b b1       	in	r24, 0x0b	; 11
 19e:	8c 73       	andi	r24, 0x3C	; 60
 1a0:	8b b9       	out	0x0b, r24	; 11
 1a2:	08 95       	ret

000001a4 <get_hall_logic>:

uint8_t get_hall_logic()
{
	
	uint8_t temp = 0; //reset state to zero
	if ( (Hall_A_PIN & Hall_A_MASK) ) { temp |= (1<<HALL_A_LOGIC_BIT); }
 1a4:	49 9b       	sbis	0x09, 1	; 9
 1a6:	02 c0       	rjmp	.+4      	; 0x1ac <get_hall_logic+0x8>
 1a8:	84 e0       	ldi	r24, 0x04	; 4
 1aa:	01 c0       	rjmp	.+2      	; 0x1ae <get_hall_logic+0xa>
}

uint8_t get_hall_logic()
{
	
	uint8_t temp = 0; //reset state to zero
 1ac:	80 e0       	ldi	r24, 0x00	; 0
	if ( (Hall_A_PIN & Hall_A_MASK) ) { temp |= (1<<HALL_A_LOGIC_BIT); }
	if ( (Hall_B_PIN & Hall_B_MASK) ) { temp |= (1<<HALL_B_LOGIC_BIT); }
 1ae:	31 99       	sbic	0x06, 1	; 6
 1b0:	82 60       	ori	r24, 0x02	; 2
	if ( (Hall_C_PIN & Hall_C_MASK) ) { temp |= (1<<HALL_C_LOGIC_BIT); }
 1b2:	4a 99       	sbic	0x09, 2	; 9
 1b4:	81 60       	ori	r24, 0x01	; 1
	return temp;
}
 1b6:	08 95       	ret

000001b8 <set_phase>:


void set_phase(char phase, char set_output_to)
{
	switch (phase) {
 1b8:	82 34       	cpi	r24, 0x42	; 66
 1ba:	99 f0       	breq	.+38     	; 0x1e2 <set_phase+0x2a>
 1bc:	83 34       	cpi	r24, 0x43	; 67
 1be:	01 f1       	breq	.+64     	; 0x200 <set_phase+0x48>
 1c0:	81 34       	cpi	r24, 0x41	; 65
 1c2:	61 f5       	brne	.+88     	; 0x21c <set_phase+0x64>
		case 'A':			
			switch (set_output_to) {
 1c4:	6c 34       	cpi	r22, 0x4C	; 76
 1c6:	39 f0       	breq	.+14     	; 0x1d6 <set_phase+0x1e>
 1c8:	6a 35       	cpi	r22, 0x5A	; 90
 1ca:	41 f0       	breq	.+16     	; 0x1dc <set_phase+0x24>
 1cc:	68 34       	cpi	r22, 0x48	; 72
 1ce:	31 f5       	brne	.+76     	; 0x21c <set_phase+0x64>
				case 'H':
					FET_A_LOW_PORT &= ~(1<<FET_A_LOW_BIT);//turn low FET off
 1d0:	2f 98       	cbi	0x05, 7	; 5
					FET_A_HIGH_PORT |= (1<<FET_A_HIGH_BIT);//turn high FET on
 1d2:	58 9a       	sbi	0x0b, 0	; 11
					break;
 1d4:	08 95       	ret
				case 'L':
					FET_A_HIGH_PORT &= ~(1<<FET_A_HIGH_BIT);//turn high FET off
 1d6:	58 98       	cbi	0x0b, 0	; 11
					FET_A_LOW_PORT |= (1<<FET_A_LOW_BIT);//turn low FET on
 1d8:	2f 9a       	sbi	0x05, 7	; 5
					break;
 1da:	08 95       	ret
				case 'Z':
					FET_A_HIGH_PORT &= ~(1<<FET_A_HIGH_BIT);//turn both FETs off
 1dc:	58 98       	cbi	0x0b, 0	; 11
					FET_A_LOW_PORT &= ~(1<<FET_A_LOW_BIT);
 1de:	2f 98       	cbi	0x05, 7	; 5
					break;
 1e0:	08 95       	ret
					break;
			}
			break;
			
		case 'B':
			switch (set_output_to) {
 1e2:	6c 34       	cpi	r22, 0x4C	; 76
 1e4:	39 f0       	breq	.+14     	; 0x1f4 <set_phase+0x3c>
 1e6:	6a 35       	cpi	r22, 0x5A	; 90
 1e8:	41 f0       	breq	.+16     	; 0x1fa <set_phase+0x42>
 1ea:	68 34       	cpi	r22, 0x48	; 72
 1ec:	b9 f4       	brne	.+46     	; 0x21c <set_phase+0x64>
				case 'H':
					FET_B_LOW_PORT &= ~(1<<FET_B_LOW_BIT);//turn low FET off
 1ee:	2e 98       	cbi	0x05, 6	; 5
					FET_B_HIGH_PORT |= (1<<FET_B_HIGH_BIT);//turn high FET on
 1f0:	40 9a       	sbi	0x08, 0	; 8
					break;
 1f2:	08 95       	ret
				case 'L':
					FET_B_HIGH_PORT &= ~(1<<FET_B_HIGH_BIT);//turn high FET off
 1f4:	40 98       	cbi	0x08, 0	; 8
					FET_B_LOW_PORT |= (1<<FET_B_LOW_BIT);//turn low FET on
 1f6:	2e 9a       	sbi	0x05, 6	; 5
					break;
 1f8:	08 95       	ret
				case 'Z':
					FET_B_HIGH_PORT &= ~(1<<FET_B_HIGH_BIT);//turn both FETs off
 1fa:	40 98       	cbi	0x08, 0	; 8
					FET_B_LOW_PORT &= ~(1<<FET_B_LOW_BIT);
 1fc:	2e 98       	cbi	0x05, 6	; 5
					break;
 1fe:	08 95       	ret
					break;
			}			
			break;
			
		case 'C':			
			switch (set_output_to) {
 200:	6c 34       	cpi	r22, 0x4C	; 76
 202:	39 f0       	breq	.+14     	; 0x212 <set_phase+0x5a>
 204:	6a 35       	cpi	r22, 0x5A	; 90
 206:	41 f0       	breq	.+16     	; 0x218 <set_phase+0x60>
 208:	68 34       	cpi	r22, 0x48	; 72
 20a:	41 f4       	brne	.+16     	; 0x21c <set_phase+0x64>
				case 'H':
					FET_C_LOW_PORT &= ~(1<<FET_C_LOW_BIT);//turn low FET off
 20c:	29 98       	cbi	0x05, 1	; 5
					FET_C_HIGH_PORT |= (1<<FET_C_HIGH_BIT);//turn high FET on
 20e:	28 9a       	sbi	0x05, 0	; 5
					break;
 210:	08 95       	ret
				case 'L':
					FET_C_HIGH_PORT &= ~(1<<FET_C_HIGH_BIT);//turn high FET off
 212:	28 98       	cbi	0x05, 0	; 5
					FET_C_LOW_PORT |= (1<<FET_C_LOW_BIT);//turn low FET on
 214:	29 9a       	sbi	0x05, 1	; 5
					break;
 216:	08 95       	ret
				case 'Z':
					FET_C_HIGH_PORT &= ~(1<<FET_C_HIGH_BIT);//turn both FETs off
 218:	28 98       	cbi	0x05, 0	; 5
					FET_C_LOW_PORT &= ~(1<<FET_C_LOW_BIT);
 21a:	29 98       	cbi	0x05, 1	; 5
 21c:	08 95       	ret

0000021e <set_all_phases>:

}


void set_all_phases(char stateA, char stateB, char stateC)
{
 21e:	cf 93       	push	r28
 220:	df 93       	push	r29
 222:	d6 2f       	mov	r29, r22
 224:	c4 2f       	mov	r28, r20
	set_phase('A',stateA);
 226:	68 2f       	mov	r22, r24
 228:	81 e4       	ldi	r24, 0x41	; 65
 22a:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <set_phase>
	set_phase('B',stateB);
 22e:	6d 2f       	mov	r22, r29
 230:	82 e4       	ldi	r24, 0x42	; 66
 232:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <set_phase>
	set_phase('C',stateC);
 236:	6c 2f       	mov	r22, r28
 238:	83 e4       	ldi	r24, 0x43	; 67
 23a:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <set_phase>
}
 23e:	df 91       	pop	r29
 240:	cf 91       	pop	r28
 242:	08 95       	ret

00000244 <main>:


int main(void)
{
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
 244:	0e 94 b2 00 	call	0x164	; 0x164 <atmel_start_init>
	hall_init();
	phase_init();
 248:	0e 94 c1 00 	call	0x182	; 0x182 <phase_init>
	adc_init();
 24c:	0e 94 77 00 	call	0xee	; 0xee <adc_init>
	timer0_init();
 250:	0e 94 b5 00 	call	0x16a	; 0x16a <timer0_init>
	
//	adc_select_channel(ADC_CHANNEL_goalRPM);

	while (1) {
		uint8_t ai_result = adc_read_latest();
 254:	0e 94 af 00 	call	0x15e	; 0x15e <adc_read_latest>
		uint8_t count_latest = TCNT0;
 258:	96 b5       	in	r25, 0x26	; 38
		
		if( count_latest > ai_result ) { //if free-running counter value is greater than arduino wants, turn off all FETs
 25a:	89 17       	cp	r24, r25
 25c:	30 f4       	brcc	.+12     	; 0x26a <main+0x26>
			set_all_phases('Z','Z','Z'); //replicate GG2 behavior
 25e:	4a e5       	ldi	r20, 0x5A	; 90
 260:	6a e5       	ldi	r22, 0x5A	; 90
 262:	8a e5       	ldi	r24, 0x5A	; 90
 264:	0e 94 0f 01 	call	0x21e	; 0x21e <set_all_phases>
 268:	f5 cf       	rjmp	.-22     	; 0x254 <main+0x10>
		
		} else { //always true when 'S8000' sent, true half the time when 'S4000', never true when 'S0'
			
			//PIND |= (1<<3); //debug... toggle PD3 (X1LIM)
			switch ( get_hall_logic() ) {
 26a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <get_hall_logic>
 26e:	83 30       	cpi	r24, 0x03	; 3
 270:	c1 f0       	breq	.+48     	; 0x2a2 <main+0x5e>
 272:	28 f4       	brcc	.+10     	; 0x27e <main+0x3a>
 274:	81 30       	cpi	r24, 0x01	; 1
 276:	49 f0       	breq	.+18     	; 0x28a <main+0x46>
 278:	82 30       	cpi	r24, 0x02	; 2
 27a:	69 f0       	breq	.+26     	; 0x296 <main+0x52>
 27c:	2a c0       	rjmp	.+84     	; 0x2d2 <main+0x8e>
 27e:	85 30       	cpi	r24, 0x05	; 5
 280:	e1 f0       	breq	.+56     	; 0x2ba <main+0x76>
 282:	a8 f0       	brcs	.+42     	; 0x2ae <main+0x6a>
 284:	86 30       	cpi	r24, 0x06	; 6
 286:	f9 f0       	breq	.+62     	; 0x2c6 <main+0x82>
 288:	24 c0       	rjmp	.+72     	; 0x2d2 <main+0x8e>
				case 1: set_all_phases('H','L','Z'); break;
 28a:	4a e5       	ldi	r20, 0x5A	; 90
 28c:	6c e4       	ldi	r22, 0x4C	; 76
 28e:	88 e4       	ldi	r24, 0x48	; 72
 290:	0e 94 0f 01 	call	0x21e	; 0x21e <set_all_phases>
 294:	df cf       	rjmp	.-66     	; 0x254 <main+0x10>
				case 2: set_all_phases('L','Z','H'); break;
 296:	48 e4       	ldi	r20, 0x48	; 72
 298:	6a e5       	ldi	r22, 0x5A	; 90
 29a:	8c e4       	ldi	r24, 0x4C	; 76
 29c:	0e 94 0f 01 	call	0x21e	; 0x21e <set_all_phases>
 2a0:	d9 cf       	rjmp	.-78     	; 0x254 <main+0x10>
				case 3: set_all_phases('Z','L','H'); break;
 2a2:	48 e4       	ldi	r20, 0x48	; 72
 2a4:	6c e4       	ldi	r22, 0x4C	; 76
 2a6:	8a e5       	ldi	r24, 0x5A	; 90
 2a8:	0e 94 0f 01 	call	0x21e	; 0x21e <set_all_phases>
 2ac:	d3 cf       	rjmp	.-90     	; 0x254 <main+0x10>
				case 4: set_all_phases('Z','H','L'); break;
 2ae:	4c e4       	ldi	r20, 0x4C	; 76
 2b0:	68 e4       	ldi	r22, 0x48	; 72
 2b2:	8a e5       	ldi	r24, 0x5A	; 90
 2b4:	0e 94 0f 01 	call	0x21e	; 0x21e <set_all_phases>
 2b8:	cd cf       	rjmp	.-102    	; 0x254 <main+0x10>
				case 5: set_all_phases('H','Z','L'); break;
 2ba:	4c e4       	ldi	r20, 0x4C	; 76
 2bc:	6a e5       	ldi	r22, 0x5A	; 90
 2be:	88 e4       	ldi	r24, 0x48	; 72
 2c0:	0e 94 0f 01 	call	0x21e	; 0x21e <set_all_phases>
 2c4:	c7 cf       	rjmp	.-114    	; 0x254 <main+0x10>
				case 6: set_all_phases('L','H','Z'); break;
 2c6:	4a e5       	ldi	r20, 0x5A	; 90
 2c8:	68 e4       	ldi	r22, 0x48	; 72
 2ca:	8c e4       	ldi	r24, 0x4C	; 76
 2cc:	0e 94 0f 01 	call	0x21e	; 0x21e <set_all_phases>
 2d0:	c1 cf       	rjmp	.-126    	; 0x254 <main+0x10>
				case 0: //fall through
				case 7: // fall through 0b000 & 0b111 are invalid hall states
				default:
					set_all_phases('Z','Z','Z'); //mainly to catch M5 pulling HallC low (when spindle disabled)
 2d2:	4a e5       	ldi	r20, 0x5A	; 90
 2d4:	6a e5       	ldi	r22, 0x5A	; 90
 2d6:	8a e5       	ldi	r24, 0x5A	; 90
 2d8:	0e 94 0f 01 	call	0x21e	; 0x21e <set_all_phases>
					break;
 2dc:	bb cf       	rjmp	.-138    	; 0x254 <main+0x10>

000002de <system_init>:
{
	/* On AVR devices all peripherals are enabled from power on reset, this
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	PRR = (1 << PRSPI) | (1 << PRTIM0) | (1 << PRCAN) | (1 << PRTIM1) | (1 << PRLIN) | (1 << PRPSC) | (1 << PRADC);
 2de:	8f e7       	ldi	r24, 0x7F	; 127
 2e0:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7f8064>
		break;
	case PORT_DIR_OUT:
		DDRB |= mask;
		break;
	case PORT_DIR_OFF:
		DDRB &= ~mask;
 2e4:	84 b1       	in	r24, 0x04	; 4
 2e6:	14 b8       	out	0x04, r1	; 4

		PORTB |= mask;
 2e8:	85 b1       	in	r24, 0x05	; 5
 2ea:	8f ef       	ldi	r24, 0xFF	; 255
 2ec:	85 b9       	out	0x05, r24	; 5
		break;
	case PORT_DIR_OUT:
		DDRC |= mask;
		break;
	case PORT_DIR_OFF:
		DDRC &= ~mask;
 2ee:	97 b1       	in	r25, 0x07	; 7
 2f0:	17 b8       	out	0x07, r1	; 7

		PORTC |= mask;
 2f2:	98 b1       	in	r25, 0x08	; 8
 2f4:	88 b9       	out	0x08, r24	; 8
		break;
	case PORT_DIR_OUT:
		DDRD |= mask;
		break;
	case PORT_DIR_OFF:
		DDRD &= ~mask;
 2f6:	9a b1       	in	r25, 0x0a	; 10
 2f8:	1a b8       	out	0x0a, r1	; 10

		PORTD |= mask;
 2fa:	9b b1       	in	r25, 0x0b	; 11
 2fc:	8b b9       	out	0x0b, r24	; 11
		break;
	case PORT_DIR_OUT:
		DDRE |= mask;
		break;
	case PORT_DIR_OFF:
		DDRE &= ~mask;
 2fe:	8d b1       	in	r24, 0x0d	; 13
 300:	88 7f       	andi	r24, 0xF8	; 248
 302:	8d b9       	out	0x0d, r24	; 13

		PORTE |= mask;
 304:	8e b1       	in	r24, 0x0e	; 14
 306:	87 60       	ori	r24, 0x07	; 7
 308:	8e b9       	out	0x0e, r24	; 14
 * \return Initialization status.
 */
static inline int8_t sysctrl_init()
{
	/* Set up system clock prescaler according to configuration */
	protected_write_io((void *)&CLKPR, 1 << CLKPCE, (0 << CLKPS3) | (0 << CLKPS2) | (0 << CLKPS1) | (0 << CLKPS0));
 30a:	40 e0       	ldi	r20, 0x00	; 0
 30c:	60 e8       	ldi	r22, 0x80	; 128
 30e:	81 e6       	ldi	r24, 0x61	; 97
 310:	90 e0       	ldi	r25, 0x00	; 0
 312:	0e 94 8e 01 	call	0x31c	; 0x31c <protected_write_io>

	SMCR = (0 << SM2) | (0 << SM1) | (0 << SM0) | // Idle
 316:	13 be       	out	0x33, r1	; 51
	       (0 << SE);

	MCUCR = (0 << PUD);
 318:	15 be       	out	0x35, r1	; 53
 31a:	08 95       	ret

0000031c <protected_write_io>:
#if defined(__GNUC__)
	/*
	 * We need to disable interrupts globally before the protected
	 * sequence. In order to do that we must save SREG first.
	 */
	in      r18,    _SFR_IO_ADDR(SREG)
 31c:	2f b7       	in	r18, 0x3f	; 63
	cli
 31e:	f8 94       	cli
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
 320:	fc 01       	movw	r30, r24
	st      Z, r22                  // Write protection bit to I/O register
 322:	60 83       	st	Z, r22
	st      Z, r20                  // Write value to I/O register
 324:	40 83       	st	Z, r20
	out     _SFR_IO_ADDR(SREG), r18
 326:	2f bf       	out	0x3f, r18	; 63

	ret                             // Return to caller
 328:	08 95       	ret

0000032a <_exit>:
 32a:	f8 94       	cli

0000032c <__stop_program>:
 32c:	ff cf       	rjmp	.-2      	; 0x32c <__stop_program>
