
My Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000406  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000003b2  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000406  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000438  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000f0  00000000  00000000  00000478  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001350  00000000  00000000  00000568  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d73  00000000  00000000  000018b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000801  00000000  00000000  0000262b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000150  00000000  00000000  00002e2c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000070e  00000000  00000000  00002f7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000028d  00000000  00000000  0000368a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000090  00000000  00000000  00003917  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
   8:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
   c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  10:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  14:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  18:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  1c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  20:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  24:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  28:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  2c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  30:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  34:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  38:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  3c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  40:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  44:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  48:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  4c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  50:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  54:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  58:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  5c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  60:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  64:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  68:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  6c:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  70:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  74:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>
  78:	0c 94 48 00 	jmp	0x90	; 0x90 <__bad_interrupt>

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d8 e0       	ldi	r29, 0x08	; 8
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61
  88:	0e 94 27 01 	call	0x24e	; 0x24e <main>
  8c:	0c 94 d7 01 	jmp	0x3ae	; 0x3ae <_exit>

00000090 <__bad_interrupt>:
  90:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000094 <adc_select_vref>:


void adc_select_vref(uint8_t reference)
{
	//"The user is advised not to write new reference selection values during Free Running mode"
	ADCSRA &= ~(1<<ADSC); //disable free running mode
  94:	ea e7       	ldi	r30, 0x7A	; 122
  96:	f0 e0       	ldi	r31, 0x00	; 0
  98:	90 81       	ld	r25, Z
  9a:	9f 7b       	andi	r25, 0xBF	; 191
  9c:	90 83       	st	Z, r25
	//while ( !(ADCSRA & (1<<ADIF)) ) {;} //wait for ADC to stop
	if(reference == VREF_EXT_AVCC) {ADMUX = ( (ADMUX & 0b00111111) | (1<<REFS0) ); } //sets ADMUX to b01xxxxxx
  9e:	81 11       	cpse	r24, r1
  a0:	07 c0       	rjmp	.+14     	; 0xb0 <adc_select_vref+0x1c>
  a2:	ec e7       	ldi	r30, 0x7C	; 124
  a4:	f0 e0       	ldi	r31, 0x00	; 0
  a6:	80 81       	ld	r24, Z
  a8:	8f 73       	andi	r24, 0x3F	; 63
  aa:	80 64       	ori	r24, 0x40	; 64
  ac:	80 83       	st	Z, r24
  ae:	08 95       	ret
	if(reference == VREF_INT_2V56) {ADMUX |= ( (1<<REFS0) | (1<<REFS1) ); } //sets ADMUX to b11xxxxxx
  b0:	81 30       	cpi	r24, 0x01	; 1
  b2:	29 f4       	brne	.+10     	; 0xbe <adc_select_vref+0x2a>
  b4:	ec e7       	ldi	r30, 0x7C	; 124
  b6:	f0 e0       	ldi	r31, 0x00	; 0
  b8:	80 81       	ld	r24, Z
  ba:	80 6c       	ori	r24, 0xC0	; 192
  bc:	80 83       	st	Z, r24
  be:	08 95       	ret

000000c0 <adc_select_channel>:


void adc_select_channel(uint8_t channel)
{
	//"The user is advised not to write new channel selection values during Free Running mode"
	ADCSRA &= ~(1<<ADSC); //disable free running mode
  c0:	ea e7       	ldi	r30, 0x7A	; 122
  c2:	f0 e0       	ldi	r31, 0x00	; 0
  c4:	90 81       	ld	r25, Z
  c6:	9f 7b       	andi	r25, 0xBF	; 191
  c8:	90 83       	st	Z, r25
	//while ( !(ADCSRA & (1<<ADIF)) ) {;} //wait for ADC to stop
	if(     channel == ADC_CHANNEL_goalRPM) {ADMUX = ( (ADMUX & 0b11100000) | 0b00000101 ); } //ADC5 (single ended)
  ca:	81 11       	cpse	r24, r1
  cc:	07 c0       	rjmp	.+14     	; 0xdc <adc_select_channel+0x1c>
  ce:	ec e7       	ldi	r30, 0x7C	; 124
  d0:	f0 e0       	ldi	r31, 0x00	; 0
  d2:	80 81       	ld	r24, Z
  d4:	80 7e       	andi	r24, 0xE0	; 224
  d6:	85 60       	ori	r24, 0x05	; 5
  d8:	80 83       	st	Z, r24
  da:	08 95       	ret
	else if(channel == ADC_CHANNEL_VCCDIV4) {ADMUX = ( (ADMUX & 0b11100000) | 0b00001100 ); } //VCC/4 (SE)
  dc:	85 30       	cpi	r24, 0x05	; 5
  de:	31 f4       	brne	.+12     	; 0xec <adc_select_channel+0x2c>
  e0:	ec e7       	ldi	r30, 0x7C	; 124
  e2:	f0 e0       	ldi	r31, 0x00	; 0
  e4:	80 81       	ld	r24, Z
  e6:	80 7e       	andi	r24, 0xE0	; 224
  e8:	8c 60       	ori	r24, 0x0C	; 12
  ea:	80 83       	st	Z, r24
  ec:	08 95       	ret

000000ee <adc_init>:
	//ADCSRA |= (1<<ADSC); //enable free running mode
}


void adc_init()
{	
  ee:	0f 93       	push	r16
  f0:	1f 93       	push	r17
  f2:	cf 93       	push	r28
  f4:	df 93       	push	r29
	DIDR0 = (1<<ADC5D);//disable digital logic on adc pin (to reduce power)(see DIDR0/DIDR1)
  f6:	80 e2       	ldi	r24, 0x20	; 32
  f8:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
	PRR &= ~(1<<PRADC); //enable system clock to ADC.  This is default value, but just making sure ADC is on
  fc:	e4 e6       	ldi	r30, 0x64	; 100
  fe:	f0 e0       	ldi	r31, 0x00	; 0
 100:	80 81       	ld	r24, Z
 102:	8e 7f       	andi	r24, 0xFE	; 254
 104:	80 83       	st	Z, r24
	ADC_goalRPM_PORT &= ~(1<<ADC_goalRPM_BIT); //disable goalRPM pullup resistor
 106:	2a 98       	cbi	0x05, 2	; 5

	ADCSRA = 0; //reset to default values
 108:	ca e7       	ldi	r28, 0x7A	; 122
 10a:	d0 e0       	ldi	r29, 0x00	; 0
 10c:	18 82       	st	Y, r1
	ADCSRA |= (1<<ADEN); //enable ADC subsystem (but doesn't actually start)
 10e:	88 81       	ld	r24, Y
 110:	80 68       	ori	r24, 0x80	; 128
 112:	88 83       	st	Y, r24
	ADCSRA |= 0b00000110; //ADPS: sets ADC clock to 16E6/64 = 250 kHz (max anecdotal supported is clock = 2 MHz).  Conversion takes 16 clock cycles, so ~15 kS/s.
 114:	88 81       	ld	r24, Y
 116:	86 60       	ori	r24, 0x06	; 6
 118:	88 83       	st	Y, r24
	ADCSRA |= (1<<ADATE); //auto-trigger enable... ADC is just always digitizing.  When we want a value, we just grab the last one acquired
 11a:	88 81       	ld	r24, Y
 11c:	80 62       	ori	r24, 0x20	; 32
 11e:	88 83       	st	Y, r24
		
	ADCSRB = 0; //reset to default values
 120:	eb e7       	ldi	r30, 0x7B	; 123
 122:	f0 e0       	ldi	r31, 0x00	; 0
 124:	10 82       	st	Z, r1
	ADCSRB |= (1<<ADHSM); //uncomment to enable high speed mode.  max ADC rate with this line commented out is 200 kHz 
 126:	80 81       	ld	r24, Z
 128:	80 68       	ori	r24, 0x80	; 128
 12a:	80 83       	st	Z, r24
	ADCSRB |= (1<<AREFEN); //connect analog reference to external AREF pin (with capacitor)
 12c:	80 81       	ld	r24, Z
 12e:	80 62       	ori	r24, 0x20	; 32
 130:	80 83       	st	Z, r24
	//ADCSRB 3:0 sets auto-trigger source selection bits 0b0000 is "free running mode", which we're using for now

	
	ADMUX = 0; //reset 
 132:	0c e7       	ldi	r16, 0x7C	; 124
 134:	10 e0       	ldi	r17, 0x00	; 0
 136:	f8 01       	movw	r30, r16
 138:	10 82       	st	Z, r1
	adc_select_vref(VREF_EXT_AVCC);  //modifies ADMUX, so needs to happen after "ADMUX=0;"
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	0e 94 4a 00 	call	0x94	; 0x94 <adc_select_vref>
	adc_select_channel(ADC_CHANNEL_goalRPM); // "always select a channel before starting the first conversion"
 140:	80 e0       	ldi	r24, 0x00	; 0
 142:	0e 94 60 00 	call	0xc0	; 0xc0 <adc_select_channel>
	ADMUX |= (1<<ADLAR); //left adjust ADC result, so that upper 8 bits are in ADCH
 146:	f8 01       	movw	r30, r16
 148:	80 81       	ld	r24, Z
 14a:	80 62       	ori	r24, 0x20	; 32
 14c:	80 83       	st	Z, r24


	ADCSRA |= (1<<ADSC); //start ADC conversion (since we're free running, we only need to set bit once)
 14e:	88 81       	ld	r24, Y
 150:	80 64       	ori	r24, 0x40	; 64
 152:	88 83       	st	Y, r24
}
 154:	df 91       	pop	r29
 156:	cf 91       	pop	r28
 158:	1f 91       	pop	r17
 15a:	0f 91       	pop	r16
 15c:	08 95       	ret

0000015e <adc_read_latest>:

//returns the latest measurement (8 bits for now)
uint8_t adc_read_latest()
{
	uint8_t adc_result = 0;
	adc_result = ADCH; //high byte ADC result
 15e:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
	return adc_result; //only 8 MSBs returned (2 LSBs in ADCL not read).  Search ADLAR to enable 10b (and note this requires two register reads, etc)
 162:	08 95       	ret

00000164 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
 164:	0e 94 b1 01 	call	0x362	; 0x362 <system_init>
 168:	08 95       	ret

0000016a <timer0_init>:

//setup TC0 to continuously count from 0:127 with auto-reload
//This is used to (poorly) control spindle speed
void timer0_init()
{
	PRR &= ~(1<<PRTIM0);//enable timer
 16a:	e4 e6       	ldi	r30, 0x64	; 100
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	80 81       	ld	r24, Z
 170:	87 7f       	andi	r24, 0xF7	; 247
 172:	80 83       	st	Z, r24
	TCCR0A = 0b10000010; //set to clear on compare
 174:	82 e8       	ldi	r24, 0x82	; 130
 176:	84 bd       	out	0x24, r24	; 36
	//TCCR0B = 0b00000101; //divide 16E6/1024 = 15.6 kHz clock, counter resets @   117  Hz
	//TCCR0B = 0b00000100; //divide 16E6/0256 = 62.5 kHz clock, counter resets @   488  Hz
	//TCCR0B = 0b00000011; //divide 16E6/0064 = 250. kHz clock, counter resets @  1.95 kHz
	TCCR0B = 0b00000010; //divide 16E6/0008 = 02.0 MHz clock, counter resets @ 15.63 kHz
 178:	82 e0       	ldi	r24, 0x02	; 2
 17a:	85 bd       	out	0x25, r24	; 37
	//TCCR0B = 0b00000001; //divide 16E6/0001 = 16.0 MHz clock, counter resets @   125 kHz
	
	OCR0A = 127; //maximum timer value to count up to (before reset); counter continuously counts up from zero to this value 
 17c:	8f e7       	ldi	r24, 0x7F	; 127
 17e:	87 bd       	out	0x27, r24	; 39
 180:	08 95       	ret

00000182 <phase_init>:
}

void phase_init()
{
	//Pull enable pin high
	BLDC_ENABLE_DDR |= BLDC_ENABLE_MASK; //configure as output
 182:	24 9a       	sbi	0x04, 4	; 4
	BLDC_ENABLE_PORT |= BLDC_ENABLE_MASK; //set pin high
 184:	2c 9a       	sbi	0x05, 4	; 5
	
	//configure phases as output
	DDRB |= FET_PORTB_MASK;
 186:	84 b1       	in	r24, 0x04	; 4
 188:	83 6c       	ori	r24, 0xC3	; 195
 18a:	84 b9       	out	0x04, r24	; 4
	DDRC |= FET_PORTC_MASK;
 18c:	38 9a       	sbi	0x07, 0	; 7
	DDRD |= FET_PORTD_MASK;
 18e:	50 9a       	sbi	0x0a, 0	; 10
	
	//set pins low
	PORTB &= ~(FET_PORTB_MASK);
 190:	85 b1       	in	r24, 0x05	; 5
 192:	8c 73       	andi	r24, 0x3C	; 60
 194:	85 b9       	out	0x05, r24	; 5
	PORTC &= ~(FET_PORTB_MASK);
 196:	88 b1       	in	r24, 0x08	; 8
 198:	8c 73       	andi	r24, 0x3C	; 60
 19a:	88 b9       	out	0x08, r24	; 8
	PORTD &= ~(FET_PORTB_MASK);
 19c:	8b b1       	in	r24, 0x0b	; 11
 19e:	8c 73       	andi	r24, 0x3C	; 60
 1a0:	8b b9       	out	0x0b, r24	; 11
 1a2:	08 95       	ret

000001a4 <get_hall_logic>:

uint8_t get_hall_logic()
{
	
	uint8_t temp = 0; //reset state to zero
	if ( (Hall_A_PIN & Hall_A_MASK) ) { temp |= (1<<HALL_A_LOGIC_BIT); }
 1a4:	49 9b       	sbis	0x09, 1	; 9
 1a6:	02 c0       	rjmp	.+4      	; 0x1ac <get_hall_logic+0x8>
 1a8:	84 e0       	ldi	r24, 0x04	; 4
 1aa:	01 c0       	rjmp	.+2      	; 0x1ae <get_hall_logic+0xa>
}

uint8_t get_hall_logic()
{
	
	uint8_t temp = 0; //reset state to zero
 1ac:	80 e0       	ldi	r24, 0x00	; 0
	if ( (Hall_A_PIN & Hall_A_MASK) ) { temp |= (1<<HALL_A_LOGIC_BIT); }
	if ( (Hall_B_PIN & Hall_B_MASK) ) { temp |= (1<<HALL_B_LOGIC_BIT); }
 1ae:	31 99       	sbic	0x06, 1	; 6
 1b0:	82 60       	ori	r24, 0x02	; 2
	if ( (Hall_C_PIN & Hall_C_MASK) ) { temp |= (1<<HALL_C_LOGIC_BIT); }
 1b2:	4a 99       	sbic	0x09, 2	; 9
 1b4:	81 60       	ori	r24, 0x01	; 1
	return temp;
}
 1b6:	08 95       	ret

000001b8 <is_direction_clockwise>:

uint8_t is_direction_clockwise()
{
	if ( BLDC_DIR_PIN & BLDC_DIR_MASK ) { return 1;}  //spin CW 
 1b8:	83 b1       	in	r24, 0x03	; 3
	else { return 0; } //spin CCW
}
 1ba:	83 fb       	bst	r24, 3
 1bc:	88 27       	eor	r24, r24
 1be:	80 f9       	bld	r24, 0
 1c0:	08 95       	ret

000001c2 <set_phase>:

void set_phase(char phase, char set_output_to)
{
	switch (phase) {
 1c2:	82 34       	cpi	r24, 0x42	; 66
 1c4:	99 f0       	breq	.+38     	; 0x1ec <set_phase+0x2a>
 1c6:	83 34       	cpi	r24, 0x43	; 67
 1c8:	01 f1       	breq	.+64     	; 0x20a <set_phase+0x48>
 1ca:	81 34       	cpi	r24, 0x41	; 65
 1cc:	61 f5       	brne	.+88     	; 0x226 <set_phase+0x64>
		case 'A':			
			switch (set_output_to) {
 1ce:	6c 34       	cpi	r22, 0x4C	; 76
 1d0:	39 f0       	breq	.+14     	; 0x1e0 <set_phase+0x1e>
 1d2:	6a 35       	cpi	r22, 0x5A	; 90
 1d4:	41 f0       	breq	.+16     	; 0x1e6 <set_phase+0x24>
 1d6:	68 34       	cpi	r22, 0x48	; 72
 1d8:	31 f5       	brne	.+76     	; 0x226 <set_phase+0x64>
				case 'H':
					FET_A_LOW_PORT &= ~(1<<FET_A_LOW_BIT);//turn low FET off
 1da:	2f 98       	cbi	0x05, 7	; 5
					FET_A_HIGH_PORT |= (1<<FET_A_HIGH_BIT);//turn high FET on
 1dc:	58 9a       	sbi	0x0b, 0	; 11
					break;
 1de:	08 95       	ret
				case 'L':
					FET_A_HIGH_PORT &= ~(1<<FET_A_HIGH_BIT);//turn high FET off
 1e0:	58 98       	cbi	0x0b, 0	; 11
					FET_A_LOW_PORT |= (1<<FET_A_LOW_BIT);//turn low FET on
 1e2:	2f 9a       	sbi	0x05, 7	; 5
					break;
 1e4:	08 95       	ret
				case 'Z':
					FET_A_HIGH_PORT &= ~(1<<FET_A_HIGH_BIT);//turn both FETs off
 1e6:	58 98       	cbi	0x0b, 0	; 11
					FET_A_LOW_PORT &= ~(1<<FET_A_LOW_BIT);
 1e8:	2f 98       	cbi	0x05, 7	; 5
					break;
 1ea:	08 95       	ret
					break;
			}
			break;
			
		case 'B':
			switch (set_output_to) {
 1ec:	6c 34       	cpi	r22, 0x4C	; 76
 1ee:	39 f0       	breq	.+14     	; 0x1fe <set_phase+0x3c>
 1f0:	6a 35       	cpi	r22, 0x5A	; 90
 1f2:	41 f0       	breq	.+16     	; 0x204 <set_phase+0x42>
 1f4:	68 34       	cpi	r22, 0x48	; 72
 1f6:	b9 f4       	brne	.+46     	; 0x226 <set_phase+0x64>
				case 'H':
					FET_B_LOW_PORT &= ~(1<<FET_B_LOW_BIT);//turn low FET off
 1f8:	2e 98       	cbi	0x05, 6	; 5
					FET_B_HIGH_PORT |= (1<<FET_B_HIGH_BIT);//turn high FET on
 1fa:	40 9a       	sbi	0x08, 0	; 8
					break;
 1fc:	08 95       	ret
				case 'L':
					FET_B_HIGH_PORT &= ~(1<<FET_B_HIGH_BIT);//turn high FET off
 1fe:	40 98       	cbi	0x08, 0	; 8
					FET_B_LOW_PORT |= (1<<FET_B_LOW_BIT);//turn low FET on
 200:	2e 9a       	sbi	0x05, 6	; 5
					break;
 202:	08 95       	ret
				case 'Z':
					FET_B_HIGH_PORT &= ~(1<<FET_B_HIGH_BIT);//turn both FETs off
 204:	40 98       	cbi	0x08, 0	; 8
					FET_B_LOW_PORT &= ~(1<<FET_B_LOW_BIT);
 206:	2e 98       	cbi	0x05, 6	; 5
					break;
 208:	08 95       	ret
					break;
			}			
			break;
			
		case 'C':			
			switch (set_output_to) {
 20a:	6c 34       	cpi	r22, 0x4C	; 76
 20c:	39 f0       	breq	.+14     	; 0x21c <set_phase+0x5a>
 20e:	6a 35       	cpi	r22, 0x5A	; 90
 210:	41 f0       	breq	.+16     	; 0x222 <set_phase+0x60>
 212:	68 34       	cpi	r22, 0x48	; 72
 214:	41 f4       	brne	.+16     	; 0x226 <set_phase+0x64>
				case 'H':
					FET_C_LOW_PORT &= ~(1<<FET_C_LOW_BIT);//turn low FET off
 216:	29 98       	cbi	0x05, 1	; 5
					FET_C_HIGH_PORT |= (1<<FET_C_HIGH_BIT);//turn high FET on
 218:	28 9a       	sbi	0x05, 0	; 5
					break;
 21a:	08 95       	ret
				case 'L':
					FET_C_HIGH_PORT &= ~(1<<FET_C_HIGH_BIT);//turn high FET off
 21c:	28 98       	cbi	0x05, 0	; 5
					FET_C_LOW_PORT |= (1<<FET_C_LOW_BIT);//turn low FET on
 21e:	29 9a       	sbi	0x05, 1	; 5
					break;
 220:	08 95       	ret
				case 'Z':
					FET_C_HIGH_PORT &= ~(1<<FET_C_HIGH_BIT);//turn both FETs off
 222:	28 98       	cbi	0x05, 0	; 5
					FET_C_LOW_PORT &= ~(1<<FET_C_LOW_BIT);
 224:	29 98       	cbi	0x05, 1	; 5
 226:	08 95       	ret

00000228 <set_all_phases>:

}


void set_all_phases(char stateA, char stateB, char stateC)
{
 228:	cf 93       	push	r28
 22a:	df 93       	push	r29
 22c:	d6 2f       	mov	r29, r22
 22e:	c4 2f       	mov	r28, r20
	set_phase('A',stateA);
 230:	68 2f       	mov	r22, r24
 232:	81 e4       	ldi	r24, 0x41	; 65
 234:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <set_phase>
	set_phase('B',stateB);
 238:	6d 2f       	mov	r22, r29
 23a:	82 e4       	ldi	r24, 0x42	; 66
 23c:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <set_phase>
	set_phase('C',stateC);
 240:	6c 2f       	mov	r22, r28
 242:	83 e4       	ldi	r24, 0x43	; 67
 244:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <set_phase>
}
 248:	df 91       	pop	r29
 24a:	cf 91       	pop	r28
 24c:	08 95       	ret

0000024e <main>:


int main(void)
{
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
 24e:	0e 94 b2 00 	call	0x164	; 0x164 <atmel_start_init>
	hall_init();
	phase_init();
 252:	0e 94 c1 00 	call	0x182	; 0x182 <phase_init>
	adc_init();
 256:	0e 94 77 00 	call	0xee	; 0xee <adc_init>
	timer0_init();
 25a:	0e 94 b5 00 	call	0x16a	; 0x16a <timer0_init>
	
//	adc_select_channel(ADC_CHANNEL_goalRPM);

	while (1) {
		uint8_t ai_result = adc_read_latest();
 25e:	0e 94 af 00 	call	0x15e	; 0x15e <adc_read_latest>
		uint8_t count_latest = TCNT0;
 262:	96 b5       	in	r25, 0x26	; 38
		
		//ai_result = lookup_PWM[ai_result]; //LUT to spoof GG2 spindle RPM behavior 
		
		if( count_latest > ai_result ) { //if free-running counter value is greater than arduino PWM output, turn off all FETs
 264:	89 17       	cp	r24, r25
 266:	30 f4       	brcc	.+12     	; 0x274 <main+0x26>
			set_all_phases('Z','Z','Z'); //replicate GG2 behavior
 268:	4a e5       	ldi	r20, 0x5A	; 90
 26a:	6a e5       	ldi	r22, 0x5A	; 90
 26c:	8a e5       	ldi	r24, 0x5A	; 90
 26e:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 272:	f5 cf       	rjmp	.-22     	; 0x25e <main+0x10>
		
		} else { //always true when 'S8000' sent, true half the time when 'S4000', never true when 'S0'
			if( is_direction_clockwise() == 0 ) //spin CCW
 274:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <is_direction_clockwise>
 278:	81 11       	cpse	r24, r1
 27a:	39 c0       	rjmp	.+114    	; 0x2ee <main+0xa0>
			{
				//PIND |= (1<<3); //debug... toggle PD3 (X1LIM)
				switch ( get_hall_logic() ) {
 27c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <get_hall_logic>
 280:	83 30       	cpi	r24, 0x03	; 3
 282:	e9 f0       	breq	.+58     	; 0x2be <main+0x70>
 284:	28 f4       	brcc	.+10     	; 0x290 <main+0x42>
 286:	81 30       	cpi	r24, 0x01	; 1
 288:	31 f1       	breq	.+76     	; 0x2d6 <main+0x88>
 28a:	82 30       	cpi	r24, 0x02	; 2
 28c:	f1 f0       	breq	.+60     	; 0x2ca <main+0x7c>
 28e:	29 c0       	rjmp	.+82     	; 0x2e2 <main+0x94>
 290:	85 30       	cpi	r24, 0x05	; 5
 292:	49 f0       	breq	.+18     	; 0x2a6 <main+0x58>
 294:	70 f0       	brcs	.+28     	; 0x2b2 <main+0x64>
 296:	86 30       	cpi	r24, 0x06	; 6
 298:	21 f5       	brne	.+72     	; 0x2e2 <main+0x94>
					case 6: set_all_phases('H','L','Z'); break;
 29a:	4a e5       	ldi	r20, 0x5A	; 90
 29c:	6c e4       	ldi	r22, 0x4C	; 76
 29e:	88 e4       	ldi	r24, 0x48	; 72
 2a0:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 2a4:	dc cf       	rjmp	.-72     	; 0x25e <main+0x10>
					case 5: set_all_phases('L','Z','H'); break;
 2a6:	48 e4       	ldi	r20, 0x48	; 72
 2a8:	6a e5       	ldi	r22, 0x5A	; 90
 2aa:	8c e4       	ldi	r24, 0x4C	; 76
 2ac:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 2b0:	d6 cf       	rjmp	.-84     	; 0x25e <main+0x10>
					case 4: set_all_phases('Z','L','H'); break;
 2b2:	48 e4       	ldi	r20, 0x48	; 72
 2b4:	6c e4       	ldi	r22, 0x4C	; 76
 2b6:	8a e5       	ldi	r24, 0x5A	; 90
 2b8:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 2bc:	d0 cf       	rjmp	.-96     	; 0x25e <main+0x10>
					case 3: set_all_phases('Z','H','L'); break;
 2be:	4c e4       	ldi	r20, 0x4C	; 76
 2c0:	68 e4       	ldi	r22, 0x48	; 72
 2c2:	8a e5       	ldi	r24, 0x5A	; 90
 2c4:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 2c8:	ca cf       	rjmp	.-108    	; 0x25e <main+0x10>
					case 2: set_all_phases('H','Z','L'); break;
 2ca:	4c e4       	ldi	r20, 0x4C	; 76
 2cc:	6a e5       	ldi	r22, 0x5A	; 90
 2ce:	88 e4       	ldi	r24, 0x48	; 72
 2d0:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 2d4:	c4 cf       	rjmp	.-120    	; 0x25e <main+0x10>
					case 1: set_all_phases('L','H','Z'); break;
 2d6:	4a e5       	ldi	r20, 0x5A	; 90
 2d8:	68 e4       	ldi	r22, 0x48	; 72
 2da:	8c e4       	ldi	r24, 0x4C	; 76
 2dc:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 2e0:	be cf       	rjmp	.-132    	; 0x25e <main+0x10>
					case 0: //fall through
					case 7: // fall through 0b000 & 0b111 are invalid hall states
					default:
						set_all_phases('Z','Z','Z'); //mainly to catch M5 pulling HallC low (when spindle disabled)
 2e2:	4a e5       	ldi	r20, 0x5A	; 90
 2e4:	6a e5       	ldi	r22, 0x5A	; 90
 2e6:	8a e5       	ldi	r24, 0x5A	; 90
 2e8:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
						break;
 2ec:	b8 cf       	rjmp	.-144    	; 0x25e <main+0x10>
				}		
			} else { //spin CW
				switch ( get_hall_logic() ) {
 2ee:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <get_hall_logic>
 2f2:	83 30       	cpi	r24, 0x03	; 3
 2f4:	c1 f0       	breq	.+48     	; 0x326 <main+0xd8>
 2f6:	28 f4       	brcc	.+10     	; 0x302 <main+0xb4>
 2f8:	81 30       	cpi	r24, 0x01	; 1
 2fa:	49 f0       	breq	.+18     	; 0x30e <main+0xc0>
 2fc:	82 30       	cpi	r24, 0x02	; 2
 2fe:	69 f0       	breq	.+26     	; 0x31a <main+0xcc>
 300:	2a c0       	rjmp	.+84     	; 0x356 <main+0x108>
 302:	85 30       	cpi	r24, 0x05	; 5
 304:	e1 f0       	breq	.+56     	; 0x33e <main+0xf0>
 306:	a8 f0       	brcs	.+42     	; 0x332 <main+0xe4>
 308:	86 30       	cpi	r24, 0x06	; 6
 30a:	f9 f0       	breq	.+62     	; 0x34a <main+0xfc>
 30c:	24 c0       	rjmp	.+72     	; 0x356 <main+0x108>
					case 1: set_all_phases('H','L','Z'); break;
 30e:	4a e5       	ldi	r20, 0x5A	; 90
 310:	6c e4       	ldi	r22, 0x4C	; 76
 312:	88 e4       	ldi	r24, 0x48	; 72
 314:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 318:	a2 cf       	rjmp	.-188    	; 0x25e <main+0x10>
					case 2: set_all_phases('L','Z','H'); break;
 31a:	48 e4       	ldi	r20, 0x48	; 72
 31c:	6a e5       	ldi	r22, 0x5A	; 90
 31e:	8c e4       	ldi	r24, 0x4C	; 76
 320:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 324:	9c cf       	rjmp	.-200    	; 0x25e <main+0x10>
					case 3: set_all_phases('Z','L','H'); break;
 326:	48 e4       	ldi	r20, 0x48	; 72
 328:	6c e4       	ldi	r22, 0x4C	; 76
 32a:	8a e5       	ldi	r24, 0x5A	; 90
 32c:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 330:	96 cf       	rjmp	.-212    	; 0x25e <main+0x10>
					case 4: set_all_phases('Z','H','L'); break;
 332:	4c e4       	ldi	r20, 0x4C	; 76
 334:	68 e4       	ldi	r22, 0x48	; 72
 336:	8a e5       	ldi	r24, 0x5A	; 90
 338:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 33c:	90 cf       	rjmp	.-224    	; 0x25e <main+0x10>
					case 5: set_all_phases('H','Z','L'); break;
 33e:	4c e4       	ldi	r20, 0x4C	; 76
 340:	6a e5       	ldi	r22, 0x5A	; 90
 342:	88 e4       	ldi	r24, 0x48	; 72
 344:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 348:	8a cf       	rjmp	.-236    	; 0x25e <main+0x10>
					case 6: set_all_phases('L','H','Z'); break;
 34a:	4a e5       	ldi	r20, 0x5A	; 90
 34c:	68 e4       	ldi	r22, 0x48	; 72
 34e:	8c e4       	ldi	r24, 0x4C	; 76
 350:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
 354:	84 cf       	rjmp	.-248    	; 0x25e <main+0x10>
					case 0: //fall through
					case 7: // fall through 0b000 & 0b111 are invalid hall states
					default:
						set_all_phases('Z','Z','Z'); //mainly to catch M5 pulling HallC low (when spindle disabled)
 356:	4a e5       	ldi	r20, 0x5A	; 90
 358:	6a e5       	ldi	r22, 0x5A	; 90
 35a:	8a e5       	ldi	r24, 0x5A	; 90
 35c:	0e 94 14 01 	call	0x228	; 0x228 <set_all_phases>
						break;
 360:	7e cf       	rjmp	.-260    	; 0x25e <main+0x10>

00000362 <system_init>:
{
	/* On AVR devices all peripherals are enabled from power on reset, this
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	PRR = (1 << PRSPI) | (1 << PRTIM0) | (1 << PRCAN) | (1 << PRTIM1) | (1 << PRLIN) | (1 << PRPSC) | (1 << PRADC);
 362:	8f e7       	ldi	r24, 0x7F	; 127
 364:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7f8064>
		break;
	case PORT_DIR_OUT:
		DDRB |= mask;
		break;
	case PORT_DIR_OFF:
		DDRB &= ~mask;
 368:	84 b1       	in	r24, 0x04	; 4
 36a:	14 b8       	out	0x04, r1	; 4

		PORTB |= mask;
 36c:	85 b1       	in	r24, 0x05	; 5
 36e:	8f ef       	ldi	r24, 0xFF	; 255
 370:	85 b9       	out	0x05, r24	; 5
		break;
	case PORT_DIR_OUT:
		DDRC |= mask;
		break;
	case PORT_DIR_OFF:
		DDRC &= ~mask;
 372:	97 b1       	in	r25, 0x07	; 7
 374:	17 b8       	out	0x07, r1	; 7

		PORTC |= mask;
 376:	98 b1       	in	r25, 0x08	; 8
 378:	88 b9       	out	0x08, r24	; 8
		break;
	case PORT_DIR_OUT:
		DDRD |= mask;
		break;
	case PORT_DIR_OFF:
		DDRD &= ~mask;
 37a:	9a b1       	in	r25, 0x0a	; 10
 37c:	1a b8       	out	0x0a, r1	; 10

		PORTD |= mask;
 37e:	9b b1       	in	r25, 0x0b	; 11
 380:	8b b9       	out	0x0b, r24	; 11
		break;
	case PORT_DIR_OUT:
		DDRE |= mask;
		break;
	case PORT_DIR_OFF:
		DDRE &= ~mask;
 382:	8d b1       	in	r24, 0x0d	; 13
 384:	88 7f       	andi	r24, 0xF8	; 248
 386:	8d b9       	out	0x0d, r24	; 13

		PORTE |= mask;
 388:	8e b1       	in	r24, 0x0e	; 14
 38a:	87 60       	ori	r24, 0x07	; 7
 38c:	8e b9       	out	0x0e, r24	; 14
 * \return Initialization status.
 */
static inline int8_t sysctrl_init()
{
	/* Set up system clock prescaler according to configuration */
	protected_write_io((void *)&CLKPR, 1 << CLKPCE, (0 << CLKPS3) | (0 << CLKPS2) | (0 << CLKPS1) | (0 << CLKPS0));
 38e:	40 e0       	ldi	r20, 0x00	; 0
 390:	60 e8       	ldi	r22, 0x80	; 128
 392:	81 e6       	ldi	r24, 0x61	; 97
 394:	90 e0       	ldi	r25, 0x00	; 0
 396:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <protected_write_io>

	SMCR = (0 << SM2) | (0 << SM1) | (0 << SM0) | // Idle
 39a:	13 be       	out	0x33, r1	; 51
	       (0 << SE);

	MCUCR = (0 << PUD);
 39c:	15 be       	out	0x35, r1	; 53
 39e:	08 95       	ret

000003a0 <protected_write_io>:
#if defined(__GNUC__)
	/*
	 * We need to disable interrupts globally before the protected
	 * sequence. In order to do that we must save SREG first.
	 */
	in      r18,    _SFR_IO_ADDR(SREG)
 3a0:	2f b7       	in	r18, 0x3f	; 63
	cli
 3a2:	f8 94       	cli
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
 3a4:	fc 01       	movw	r30, r24
	st      Z, r22                  // Write protection bit to I/O register
 3a6:	60 83       	st	Z, r22
	st      Z, r20                  // Write value to I/O register
 3a8:	40 83       	st	Z, r20
	out     _SFR_IO_ADDR(SREG), r18
 3aa:	2f bf       	out	0x3f, r18	; 63

	ret                             // Return to caller
 3ac:	08 95       	ret

000003ae <_exit>:
 3ae:	f8 94       	cli

000003b0 <__stop_program>:
 3b0:	ff cf       	rjmp	.-2      	; 0x3b0 <__stop_program>
